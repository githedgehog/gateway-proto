// Copyright 2025 Hedgehog
// SPDX-License-Identifier: Apache-2.0

syntax = "proto3";

package config;

import "google/protobuf/duration.proto";

option go_package = "pkg/dataplane";

service ConfigService {
  rpc GetConfig (GetConfigRequest) returns (GatewayConfig);
  rpc GetConfigGeneration (GetConfigGenerationRequest) returns (GetConfigGenerationResponse);
  rpc UpdateConfig (UpdateConfigRequest) returns (UpdateConfigResponse);
  rpc GetDataplaneStatus (GetDataplaneStatusRequest) returns (GetDataplaneStatusResponse);
}

message GetConfigRequest {
}

message UpdateConfigRequest {
  GatewayConfig config = 1;
}

message UpdateConfigResponse {
  Error error = 1;
  string message = 2;
}

enum Error {
  ERROR_NONE = 0;
  ERROR_VALIDATION_FAILED = 1;
  ERROR_APPLY_FAILED = 2;
  ERROR_UNKNOWN_ERROR = 3;
}

message GetConfigGenerationRequest {
}

message GetConfigGenerationResponse {
  int64 generation = 1;
}

/* ================================================ */
/* ==== OSPF Configuration                     ==== */
/* ================================================ */

/* OSPF Network Type */
enum OspfNetworkType {
  BROADCAST = 0;
  NON_BROADCAST = 1;
  POINT_TO_POINT = 2;
  POINT_TO_MULTIPOINT = 3;
}

/* OSPF Interface configuration */
message OspfInterface {
  bool passive = 1;
  string area = 2;
  optional uint32 cost = 3;
  optional OspfNetworkType network_type = 4;
}

/* OSPF process configuration */
message OspfConfig {
  string router_id = 1;
  optional string vrf = 2;
}

/* ========================== */
/* ==== Dataplane Status ==== */
/* ========================== */

enum InterfaceStatusType {
  INTERFACE_STATUS_UNKNOWN = 0;
  INTERFACE_STATUS_OPER_UP = 1;
  INTERFACE_STATUS_OPER_DOWN = 2;
  INTERFACE_STATUS_ERROR = 3;
}

enum InterfaceAdminStatusType {
  INTERFACE_ADMIN_STATUS_UNKNOWN = 0;
  INTERFACE_ADMIN_STATUS_UP = 1;
  INTERFACE_ADMIN_STATUS_DOWN = 2;
}

/* TODO: Consider adding additional states such as FRR_STATUS_STARTING, FRR_STATUS_STOPPING, 
   or other states that might be relevant for tracking the lifecycle of FRR processes. */
enum ZebraStatusType {
  ZEBRA_STATUS_NOT_CONNECTED = 0;
  ZEBRA_STATUS_CONNECTED = 1;
}

enum FrrAgentStatusType {
  FRR_AGENT_STATUS_NOT_CONNECTED = 0;
  FRR_AGENT_STATUS_CONNECTED = 1;
}

enum DataplaneStatusType {
  DATAPLANE_STATUS_UNKNOWN = 0;
  DATAPLANE_STATUS_HEALTHY = 1;
  DATAPLANE_STATUS_INIT = 2;
  DATAPLANE_STATUS_ERROR = 3;
}

message GetDataplaneStatusRequest {
}

/* TODO: Consider adding an optional string field to InterfaceStatus for additional error messages or descriptions. */
message InterfaceStatus {
  string ifname = 1;
  InterfaceStatusType status = 2;
  InterfaceAdminStatusType admin_status = 3;
}

message FrrStatus {
  ZebraStatusType zebra_status = 1;
  FrrAgentStatusType frr_agent_status = 2;
  uint32 applied_config_gen = 3;
  uint32 restarts = 4;
  uint32 applied_configs = 5;
  uint32 failed_configs = 6;
}

message DataplaneStatusInfo {
  DataplaneStatusType status = 1;
}

/* ===================================================== */
/* ================= Extended status =================== */
/* ===================================================== */

/* ---- Interface status details ---- */

message InterfaceCounters {
  uint64 tx_bits = 1;
  double tx_bps = 2; // Maybe don't include that
  uint64 tx_errors = 3;
  uint64 rx_bits = 4;
  double rx_bps = 5;  // Here as well
  uint64 rx_errors = 6;
}

message InterfaceRuntimeStatus {
  InterfaceAdminStatusType admin_status = 1;
  InterfaceStatusType oper_status = 2;
  string mac = 3;
  uint32 mtu = 4;
  InterfaceCounters counters = 5;
}

/* ---- BGP status ---- */

enum BgpNeighborSessionState {
  BGP_STATE_UNSET = 0;
  BGP_STATE_IDLE = 1;
  BGP_STATE_CONNECT = 2;
  BGP_STATE_ACTIVE = 3;
  BGP_STATE_OPEN = 4;
  BGP_STATE_ESTABLISHED = 5;
}

message BgpMessageCounters {
  uint64 capability = 1;
  uint64 keepalive = 2;
  uint64 notification = 3;
  uint64 open = 4;
  uint64 route_refresh = 5;
  uint64 update = 6;
}

message BgpMessages {
  BgpMessageCounters received = 1;
  BgpMessageCounters sent = 2;
}

message BgpNeighborPrefixes {
  uint32 received = 1;
  uint32 received_pre_policy = 2;
  uint32 sent = 3;
}

message BgpNeighborStatus {
  bool enabled = 1;
  uint32 local_as = 2;
  uint32 peer_as = 3;
  uint32 peer_port = 4;
  string peer_group = 5;
  string remote_router_id = 6;
  BgpNeighborSessionState session_state = 7;
  uint64 connections_dropped = 8;
  uint64 established_transitions = 9;
  string last_reset_reason = 10;
  BgpMessages messages = 11;
  // e.g. "IPV4_UNICAST", "IPV6_UNICAST", "L2VPN_EVPN"
  map<string, BgpNeighborPrefixes> prefixes = 12;
}

message BgpVrfStatus {
  // key: neighbor address (IP string)
  map<string, BgpNeighborStatus> neighbors = 1;
}

message BgpStatus {
  // key: VRF name
  map<string, BgpVrfStatus> vrfs = 1;
}

message VpcInterfaceStatus {
  string ifname = 1;
  InterfaceAdminStatusType admin_status = 2;
  InterfaceStatusType oper_status = 3;
}

message VpcStatus {
  string id = 1;      // matches VPC.id
  string name = 2;    // matches VPC.name
  uint32 vni = 3;
  uint32 route_count = 4;       // routes inside AF_UNICAST, TODO: add more later
  // key: interface name
  map<string, VpcInterfaceStatus> interfaces = 7;
}

/* ---- VPCâ†”VPC dataplane counters ---- */

message VpcPeeringCounters {
  string name = 1;
  string src_vpc = 2;
  string dst_vpc = 3;
  uint64 packets = 4;
  uint64 bytes = 5;
  uint64 drops = 6;
  double pps = 7;
  uint64 active_flows = 8; // Nice to have thingy if we are doing flow tracking
}

message GetDataplaneStatusResponse {
  repeated InterfaceStatus interface_statuses = 1;
  FrrStatus frr_status = 2;
  DataplaneStatusInfo dataplane_status = 3;
  // key: ifname
  map<string, InterfaceRuntimeStatus> interface_runtime = 4;
  BgpStatus bgp = 5;
  // key: VPC name
  map<string, VpcStatus> vpcs = 6;
  // key: peering name
  map<string, VpcPeeringCounters> vpc_peering_counters = 7;
}

/* ================================================ */
/* ==== Interfaces (both underlay and overlay) ==== */
/* ================================================ */

/* Defines a logical interface. May correlate with physical representation */
message Interface {
  string name = 1;
  repeated string ipaddrs = 2;
  IfType type = 3;
  IfRole role = 4;
  optional uint32 vlan = 5; /* only if VLAN role is defined */
  optional string macaddr = 6; /* Base MAC address to be used to generate unified MAC for VTEP */
  optional string system_name = 7; /* Parent interface for VLAN devices, only for VLAN role */
  optional OspfInterface ospf = 8; /* OSPF interface configuration if enabled */
  optional uint32 mtu = 9; /* MTU for the interface */
}

/* Defines interface representation on the Gateway */
enum IfType {
  IF_TYPE_ETHERNET = 0;
  IF_TYPE_VLAN = 1;
  IF_TYPE_LOOPBACK = 2;
  IF_TYPE_VTEP = 3;
}

/* For physical interface - fabric-facing or external-facing */
enum IfRole {
  IF_ROLE_FABRIC = 0;
  IF_ROLE_EXTERNAL = 1;
}

/* ================= */
/* ==== Overlay ==== */
/* ================= */

/* Defines the list of prefixes that VPCs can expose */
message PeeringIPs {
  oneof rule {
    string cidr = 1;
    string not = 2;
  }
}

/* Defines the list of prefixes that exposing IPs will be translated to */
message PeeringAs {
  oneof rule {
    string cidr = 1;
    string not = 2;
  }
}

message PeeringStatelessNAT {}
message PeeringStatefulNAT {
    google.protobuf.Duration idleTimeout = 1;
}

/* Defines a rule between exposing IP and translated */
message Expose {
  repeated PeeringIPs ips = 1;
  repeated PeeringAs as = 2;
  oneof nat {
    PeeringStatelessNAT stateless = 3;
    PeeringStatefulNAT stateful = 4;
  }
}

/* Defines a list of exposures per VPC */
message PeeringEntryFor {
  string vpc = 1;
  repeated Expose expose = 2;
}

/* Defines peering relation between VPCs */
/* There can be only one peering per pair of given VPCs */
message VpcPeering {
  string name = 1; /* unique: e.g. VPC-1--VPC-2 */
  repeated PeeringEntryFor for = 2; /* it's guaranteed that only two entries are present */
}

message VPC {
  string id = 1; /* unique */
  string name = 2; /* unique (key) */
  uint32 vni = 3;
  repeated Interface interfaces = 4;
}

/* Description of VPCs and Peerings between VPCs */
message Overlay {
  repeated VPC vpcs = 1;
  repeated VpcPeering peerings = 2;
}

/* ================== */
/* ==== Underlay ==== */
/* ================== */

/* BGP options for IPv4 UNICAST AFI */
message BgpAddressFamilyIPv4 {
  bool redistribute_connected = 1;
  bool redistribute_static = 2;
  repeated string networks = 3;
}

/* BGP options for IPv6 UNICAST AFI */
message BgpAddressFamilyIPv6 {
  bool redistribute_connected = 1;
  bool redistribute_static = 2;
  repeated string networks = 3;
}

/* BGP options for L2VPN EVPN AFI */
message BgpAddressFamilyL2vpnEvpn {
  bool advertise_all_vni = 1;
}

/* AFIs supported for BGP peering */
enum BgpAF {
  IPV4_UNICAST = 0;
  IPV6_UNICAST = 1;
  L2VPN_EVPN = 2;
}

message BgpNeighborUpdateSource {
  oneof source {
    string address = 1; /* ip address */
    string interface = 2; /* name of interface - typically loopback */
  }
}

/* BGP neighbor config */
message BgpNeighbor {
  string address = 1;
  string remote_asn = 2;
  repeated BgpAF af_activate = 3;
  BgpNeighborUpdateSource update_source = 4;
}

/* IP Prefix filtering route map description */
message RouteMap {
  string name = 1;
  repeated string match_prefix_lists = 2;
  string action = 3;
  uint32 sequence = 4;
}

/* BGP Router config description for VRFs */
message RouterConfig {
  string asn = 1;
  string router_id = 2;
  repeated BgpNeighbor neighbors = 3;
  optional BgpAddressFamilyIPv4 ipv4_unicast = 4;
  optional BgpAddressFamilyIPv6 ipv6_unicast = 5;
  optional BgpAddressFamilyL2vpnEvpn l2vpn_evpn = 6;
  repeated RouteMap route_maps = 7;
}

/* VRF description with list of connected interfaces and its BGP config */
message VRF {
  string name = 1;
  repeated Interface interfaces = 2;
  optional RouterConfig router = 3;
  optional OspfConfig ospf = 4; /* OSPF process configuration if enabled */
}

/* List of all non-VPC VRFs */
message Underlay {
  repeated VRF vrfs = 1;
}

/* ================ */
/* ==== Device ==== */
/* ================ */

/* Defines physical or system-level device */
message Ports {
  string name = 1;
  string system_name = 2;
}

/* RTE EAL config options for DPDK */
message Eal {
  // TODO:
  // rte_eal params
  // cpu list
  // cpu affinities ...
  // huge-pages
}

/* Log-level for dataplane and DPDK */
enum LogLevel {
  OFF = 0;
  ERROR = 1;
  WARNING = 2;
  INFO = 3;
  DEBUG = 4;
  TRACE = 5;
}

message TracingConfig {
  LogLevel default = 1;
  map<string, LogLevel> taglevel = 2;
}

/* Backend driver for packet processing */
enum PacketDriver {
  KERNEL = 0;
  DPDK = 1;
}

/* System level config options */
message Device {
  PacketDriver driver = 1;
  Eal eal = 2;
  repeated Ports ports = 3;
  string hostname = 4;
  TracingConfig tracing = 5;
}

/* ================ */
/* ====== All ===== */
/* ================ */

/* Complete Gateway config options */
message GatewayConfig {
  int64 generation = 1;
  Device device = 2;
  Underlay underlay = 3;
  Overlay overlay = 4;
}
